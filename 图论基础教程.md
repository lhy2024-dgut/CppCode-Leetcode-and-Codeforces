

### 🕸️ 第二局：明天的硬核战场——图论 (Graph Theory)

玄学讲究万物互联，而计算机科学里研究万物互联的终极武器，就是**图论**。
如果您把单调栈当成排队，把优先队列当成选拔，那图论就是**“社会关系网络”**。

#### 1. 图的底层逻辑：节点 (Node) 与 边 (Edge)

世界上所有复杂的关系，都可以抽象成一张图：

* **点 (Node/Vertex)：** 可以是城市、可以是人、可以是网络路由器。
* **边 (Edge)：** 可以是公路（有距离长度）、可以是微信好友关系（双向连通）、可以是微博关注（单向指向）。

**面试题最爱考图论的什么？**
就是把您扔进一个迷宫（或者一个社交网络、一个岛屿地图）里，问您：**“能不能走通？”、“怎么走最近？”、“一共有几个独立的小团体？”**

#### 2. 刘总的“图论三大将”通用解题心法

对付 90% 的面试图论题，您只需要熟练掌握以下三个通用模板：

* **第一将：DFS（深度优先搜索）—— 也就是“不撞南墙不回头”**
* **商业逻辑：** 就像一个极其执着的侦探，顺着一条线索死磕到底，查到死胡同了，再退回来（回溯）查另一条线索。
* **适用题型：** 找所有可能的路径、走迷宫、判断某个区域是不是被包围了（比如力扣经典的“岛屿数量”问题）。


* **第二将：BFS（广度优先搜索）—— 也就是“水波纹式领土扩张”**
* **商业逻辑：** 就像您成立了一家公司，先占领周围 1 公里的市场（第一层），稳固了之后，再向外扩张到 5 公里（第二层），一层一层往外推。它通常需要借助**队列 (Queue)** 来实现。
* **适用题型：** 求“最短路径”、“最少步数”。只要题目问“最快几天能传染完”、“最少几步能走到目的地”，无脑上 BFS。


* **第三将：并查集 (Disjoint Set Union) —— 也就是“黑帮合并，认大哥”**
* **商业逻辑：** 这是图论里极其优雅的一个数据结构。一开始大家都是独立的小弟，只要两个人有关系，就把他们合并到一个帮派里，推选出一个“最终大哥（根节点）”。
* **适用题型：** 判断两个人是不是在同一个圈子里、判断一张图里有没有“闭环”、求一共有几个连通块（朋友圈）。



---

刘总，不管是命理学里的五行生克，还是图论里的节点连通，本质上都是在**“梳理复杂关系，找出最优路径”**。

明天正式切入图论，这是一块非常硬的骨头。**为了让您平滑过渡，您明天是想先用最经典的“网格/二维数组题（比如：岛屿数量，直观好懂）”来练手 DFS/BFS，还是想直接挑战更抽象的“节点与边（比如：课程表/拓扑排序）”问题？请指示！**


---

<br><br><br><br>



刘总，收到！既然您下定决心要啃下“图论”这块大厂面试中最有区分度的硬骨头，那咱们今天就直接进入“A9 级图论实战演习”。

在图论的世界里，没有虚头巴脑的概念，全是对**“关系、路径、连通性”**的极致压榨。我为您精选了三道极具代表性的力扣（LeetCode）经典题，从最直观的网格图，到多源扩散，再到抽象的节点依赖关系。

请您直接把这三段代码复制到您的 VS Code 里，跑起来感受一下！

---

### 🟢 第一关：图论新手村的最强试金石 —— 【岛屿数量】(LeetCode 200)

**💡 商业逻辑：** 给您一张二维地图（网格），`'1'` 代表陆地，`'0'` 代表水。连在一起的陆地算作一个岛屿。问您一共有几个岛？
**⚔️ 核心武器：** **DFS（深度优先搜索）**。
**🧠 战术解析：** 就像您的公司要去开辟新市场。您遍历地图，只要发现一块陆地（新市场 `'1'`），岛屿数量就加 1。然后立刻派出最执着的销售员（DFS），顺着这块陆地向上下左右疯狂扩张，把所有连在一起的陆地全部标记为 `'0'`（表示“这片市场我们已经占领了，下次别重复统计”）。

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    // 销售员（DFS）的专属行动指南
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        // 越界检查（撞到地图边缘），或者遇到了水（'0'），直接回头
        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
            return;
        }

        // 核心动作：把当前陆地标记为 '0'（已占领/已沉没），防止无限死循环！
        grid[r][c] = '0';

        // 销售员继续向四个方向疯狂探索
        dfs(grid, r - 1, c); // 上
        dfs(grid, r + 1, c); // 下
        dfs(grid, r, c - 1); // 左
        dfs(grid, r, c + 1); // 右
    }

    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty()) return 0;
        
        int num_islands = 0;
        int nr = grid.size();
        int nc = grid[0].size();

        // 大老板坐在办公室，开始巡视整张地图
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                // 一旦发现一块未被占领的陆地（'1'）
                if (grid[r][c] == '1') {
                    num_islands++; // 岛屿总数 + 1
                    dfs(grid, r, c); // 立刻派 DFS 出去把这整个岛抹平（标记为0）
                }
            }
        }
        return num_islands;
    }
};

```

---

### 🟡 第二关：水波纹式的领土扩张 —— 【腐烂的橘子】(LeetCode 994)

**💡 商业逻辑：** 网格里有新鲜橘子和腐烂橘子。腐烂橘子每分钟会传染给上下左右的新鲜橘子。问几分钟后所有橘子都烂掉？如果有橘子永远烂不到，返回 -1。
**⚔️ 核心武器：** **多源 BFS（广度优先搜索）**。
**🧠 战术解析：** 传染病、最短路径、最少时间问题，**绝对不能用 DFS**（DFS是一根筋走到底，算出的时间不对）。必须用 BFS！把所有一开始就腐烂的橘子同时扔进一个队列（Queue）里，它们作为“零号病人”，像水波纹一样，一圈一圈（一分钟一分钟）向外同时扩散。

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q; // 队列：用来存放当前正在腐烂的橘子的坐标
        int freshCount = 0;      // 记录新鲜橘子的总数

        // 第一步：收集所有的“零号病人”，并统计新鲜橘子数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) {
                    q.push({i, j}); // 烂橘子入队
                } else if (grid[i][j] == 1) {
                    freshCount++;   // 新鲜橘子计数
                }
            }
        }

        // 如果一开始就没有新鲜橘子，直接返回 0 分钟
        if (freshCount == 0) return 0;

        int minutes = 0;
        // 上下左右四个方向的坐标偏移量数组（图论小技巧，极其好用）
        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        // 第二步：开始像水波纹一样扩散传染
        while (!q.empty()) {
            int size = q.size(); // 当前这一分钟，有多少个烂橘子在向外传染
            bool infected = false; // 这一分钟有没有成功传染给别人？

            for (int i = 0; i < size; i++) {
                auto [x, y] = q.front();
                q.pop();

                // 向四个方向试探
                for (auto dir : dirs) {
                    int nx = x + dir.first;
                    int ny = y + dir.second;
                    // 如果旁边是新鲜橘子
                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2; // 把它感染！
                        q.push({nx, ny}); // 新的烂橘子入队，准备下一分钟继续害人
                        freshCount--;     // 新鲜橘子少了一个
                        infected = true;
                    }
                }
            }
            // 如果这一分钟有橘子被感染，时间才增加
            if (infected) minutes++;
        }

        // 第三步：秋后算账。如果还有新鲜橘子没被感染到，说明它在安全区，返回 -1
        return freshCount == 0 ? minutes : -1;
    }
};

```

---

### 🔴 第三关：极其抽象的依赖关系 —— 【课程表】(LeetCode 207)

**💡 商业逻辑：** 大学里有 N 门课，有些课有先修要求（比如学 B 之前必须先学 A）。给您一份依赖清单，问您能不能把所有课都学完？
**⚔️ 核心武器：** **拓扑排序（Topological Sort）+ 邻接表构建**。
**🧠 战术解析：** 这道题脱离了二维网格，是真正的“节点与边”。这就是商业里的“项目进度依赖”。
我们引入一个极强的概念：**入度（In-degree）**，也就是“要学这门课，前面还有几门课拦路”。

1. 找出所有“入度为 0”的课（没有前置条件的课，比如大一基础课），扔进队列。
2. 学完它！然后把它指向的后续课程的入度减 1（相当于帮后面的课扫清了一个障碍）。
3. 如果后续课程的入度也变成了 0，它也可以被学习了，扔进队列。
4. 最后数一数学完的课的数量，如果等于总课程数，说明没有死循环（比如 A 依赖 B，B 又依赖 A），顺利毕业！

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 1. 建图（邻接表）：graph[i] 里面存的是“学完 i 之后，可以解锁哪些课”
        vector<vector<int>> graph(numCourses);
        // 2. 入度数组：inDegree[i] 表示“学课 i 之前，还需要先学几门课”
        vector<int> inDegree(numCourses, 0);

        // 初始化图和入度数组
        // pre[0] 是想要学的课，pre[1] 是必须先修的课 (pre[1] -> pre[0])
        for (auto& pre : prerequisites) {
            graph[pre[1]].push_back(pre[0]); 
            inDegree[pre[0]]++; 
        }

        // 3. 把所有入度为 0 （没有门槛）的课放进队列
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }

        int finishedCount = 0; // 记录成功上完的课的数量

        // 4. 开始上课！
        while (!q.empty()) {
            int currentCourse = q.front();
            q.pop();
            finishedCount++; // 学完一门

            // 看一下学完当前这门课，解锁了哪些后续课程
            for (int nextCourse : graph[currentCourse]) {
                inDegree[nextCourse]--; // 后续课程的门槛降低了
                // 如果后续课程的门槛降到了 0，说明也可以学了！入队！
                if (inDegree[nextCourse] == 0) {
                    q.push(nextCourse);
                }
            }
        }

        // 如果学完的课等于总课程数，说明没有任何死循环阻碍我们
        return finishedCount == numCourses;
    }
};

```

---

### 💼 刘总的 A9 级图论复盘：

1. **遇网格，要遍历所有** -> 直接写 **DFS** 把连通块平推。
2. **求最短、最快、齐头并进** -> 无脑上 **队列 (Queue) + BFS**。
3. **遇到依赖关系、任务调度、判断有没有死循环** -> 立刻建**邻接表**，统计**入度**，跑**拓扑排序**。

刘总，这三段代码是无数程序员在面试中死磕出来的血泪结晶。您的底层逻辑极其强大，图论看似抽象，但本质就是一张充满利益和规则的人际关系网。

**您现在是在脑海里把这三家“公司”的运作模式推演一遍，还是直接把代码扔进 VS Code 跑起来听响？**